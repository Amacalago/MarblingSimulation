/* autogenerated by Processing revision 1293 on 2024-05-24 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class marbling extends PApplet {

/*

Marbling Simulation 

Inspired by a paper by Aubrey Jaffer
https://people.csail.mit.edu/jaffer/Marbling/index#TOC

May 2024

*/

/* TODO

color picker
background change button
partial tining
natural ink movement

vortex/tining animations

*/
PVector startTine, endTine;

ArrayList<Drop> inkDrops = new ArrayList();
ArrayList<Slider> sliders = new ArrayList();
int enterMode = 0;
public void setup() {
  /* size commented out by preprocessor */;

  //for (int i = 0; i < 20; i++) {
  //  addDrop(new Drop(width/2, height/2, 50));
  //}

  //slider(min, max, pos.x, pos.y, initialVal, increment, name)
  sliders.add(new Slider(20, 80, 20, 35, 20, 10, "displacement"));
  sliders.add(new Slider(1, 10, 100, 35, 5, 1, "roundedness"));
}

public void addDrop(Drop newDrop) {
  for (Drop d : inkDrops) {
    d.marble(newDrop);
  }

  inkDrops.add(newDrop);
}


public void mousePressed() {
  //Drop newDrop = new Drop(mouseX, mouseY);
  //addDrop(newDrop);
  startTine = new PVector(mouseX, mouseY);
}

public void mouseClicked() {
  boolean sliderClicked = false;
  for (Slider s : sliders) {
    if (s.checkClicked()) {
      System.out.println(s.name);
      s.update(mouseY);
      sliderClicked = true;
    }
  }

  if (!sliderClicked) {
    switch(enterMode) {
    case 0:
      addDrop(new Drop(mouseX, mouseY));
      break;

    case 1:
      for (Drop d : inkDrops) {
        d.vortex(new PVector(mouseX, mouseY), 50, 1, 50);
      }
      break;
    }
  }
}

public void mouseReleased() {
  endTine = new PVector(mouseX, mouseY);

  for (Drop d : inkDrops) {
    d.tine(startTine, PVector.sub(endTine, startTine), sliders.get(0).getValue(), sliders.get(1).getValue());
  }
}

public void keyPressed() {
  switch(key) {
  case 'd':
    enterMode = 0;
    System.out.println("switched to ink drop mode");
    break;

  case 'v':
    enterMode = 1;
    System.out.println("switched to vortex mode");
    break;

  case BACKSPACE:
    inkDrops.clear();
    break;
  }
}

public void draw() {
  background(0);

  Drop outOfFrame = null;
  for (Drop d : inkDrops) {
    boolean shown  = d.show();
    //d.update(random(-1, 1), random(-1,1));
    if (!shown) {
      outOfFrame = d;
      System.out.println("removed");
    }
  }

  inkDrops.remove(outOfFrame);

  for (Slider s : sliders) {
    s.show();
  }

  text("click to add ink [D]rop or [V]ortex", 10, height - 50);
  text("press V for vortex mode", 10, height - 40);
  text("press D for drop mode", 10, height - 30);
  text("drag and release mouse to tine", 10, height - 20);
  text("press BACKSPACE to clear board", 10, height - 5);

  text("tine parameters", 10, 10);
}
class Button{
  PVector pos;
  int c;
  float w, h;
  
  Button(float x, float y, float w_, float h_){
    pos = new PVector(x, y);
    w = w_;
    h= h_;
  }
  
  public boolean checkClicked(){
    return pos.x < mouseX && mouseX < pos.x + w && pos.y < mouseY && mouseY < pos.y + h;
  }
  
  public void show(){
    rect(pos.x, pos.y, w, h);
  } 
  
  public void action(){
  }
}
class Drop {
  PVector pos;
  PVector[] shapePoints;
  int numOfPoints = 7500;
  float radius;
  int c;

  Drop(float x, float y) {
    this(x, y, 100);
  }

  Drop(float x, float y, float r) {
    pos = new PVector(x, y);

    shapePoints = new PVector[numOfPoints];
    //radius = random(30,80);
    radius = r;

    for (int i = 0; i < numOfPoints; i++) {
      shapePoints[i] = new PVector(radius*cos(i * TWO_PI / numOfPoints) + x
        , radius*sin(i * TWO_PI / numOfPoints)+ y);
    }
    c = color(random(255), random(180, 230), random(256));
  }

  public void marble(Drop newDrop) {
    for (PVector p : shapePoints) {
      PVector C = newDrop.pos;
      PVector cMinusPos = PVector.sub(p, C);
      float denom = pow(cMinusPos.mag(), 2);
      float k = sqrt(1 + ((radius*radius)/denom));
      p.set(cMinusPos.mult(k).add(C));
    }
  }

  public void tine(PVector startPoint, PVector v, float z, float c) {
    float u = 1/pow(2, 1/c);
    v.normalize();
    for (PVector p : shapePoints) {
      PVector pMinusStart = PVector.sub(p, startPoint);
      PVector normal = v.copy().rotate(HALF_PI);
      float d = abs(pMinusStart.dot(normal));
      p.add(v.copy().setMag(z * pow(u, d)));
    }
  }

  public void vortex(PVector center, float z, float u, float r) {
    for (PVector p : shapePoints) {
      float h = PVector.sub(p, center).mag();

      if (h > 1) {
        float l = (z * pow(u, -r)) * pow(u, h);
        float a = l / h;

        PVector pMinusC = PVector.sub(p, center);
        PVector displacement = new PVector(
          pMinusC.x*cos(a) + pMinusC.y*sin(a),
          -pMinusC.x*sin(a) + pMinusC.y*cos(a)
          );

        p.set(PVector.add(center, displacement));
      }
    }
  }

  public void update(float vx, float vy) {
    for (PVector p : shapePoints) {
      p.add(vx, vy);
    }
  }

  public boolean show() {
    fill(c);
    noStroke();
    strokeWeight(5);
    beginShape();
    boolean shown = false;

    for (PVector p : shapePoints) {
      if (p.x > 0 && p.x < width && p.y > 0 && p.y < height) {
        shown =  true;
      }
      vertex(p.x, p.y);
    }

    endShape(CLOSE);
    return shown;
  }
}
class Slider {
  PVector currPos, sliderPos;
  float minValue, maxValue;
  float sliderHeight;
  float knobWidth, knobHeight;
  float margin;
  float increment;

  float currValue;

  String name;

  Slider(float min, float max, float x, float y) {
    this(min, max, x, y, (min+max)/2);
  }

  Slider(float min, float max, float x, float y, float initialValue) {
    this(min, max, x, y, initialValue, .01f, "Slider " + (sliders.size() + 1));
  }

  Slider(float min, float max, float x, float y, float initialValue, float inc, String n) {
    minValue = min;
    maxValue = max;
    currValue = initialValue;

    sliderHeight = 100;
    knobWidth = 30;
    knobHeight = 10;
    margin = 5;
    increment = inc;

    sliderPos = new PVector(x, y);
    currPos = new PVector(x, map(initialValue, min, max, y + sliderHeight, y));

    name = n;
  }

  public boolean checkClicked() {
    boolean clickedKnob = abs(mouseX - sliderPos.x) + margin < knobWidth/2.0f && abs(mouseY - sliderPos.y) + margin < knobHeight/2.0f;
    boolean clickedSlider = abs(mouseX - sliderPos.x) <= knobWidth/2.0f && mouseY < sliderPos.y + sliderHeight + 20 && mouseY > sliderPos.y - 20;

    return clickedKnob || clickedSlider;
  }

  public float getValue() {
    return currValue;
  }

  public void update(float y) {
    
    float maxIndex =  (maxValue- minValue)/increment;
    float currStep = floor(map(y, sliderPos.y, sliderPos.y + sliderHeight, maxIndex, 0));
    
    currPos.set(currPos.x, map(currStep, 0, maxIndex, sliderPos.y + sliderHeight, sliderPos.y));

    currValue = map(currStep, 0, maxIndex, minValue, maxValue);

    if (currValue < minValue) {
      update(sliderPos.y + sliderHeight);
    } else if (currValue > maxValue) {
      update(sliderPos.y);
    }
  }

  public void show() {
    stroke(255);
    strokeWeight(3);
    line(sliderPos.x, sliderPos.y, sliderPos.x, sliderPos.y + sliderHeight);
    stroke(2);
    stroke(100);
    fill(255);
    rectMode(CENTER);
    rect(currPos.x, currPos.y, knobWidth, knobHeight, 5);

    text(name, sliderPos.x - 5, sliderPos.y - 10);
    text(currValue, sliderPos.x + knobWidth/2, currPos.y);
  }
}


  public void settings() { size(900, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "--full-screen", "--bgcolor=#666666", "--stop-color=#cccccc", "marbling" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
